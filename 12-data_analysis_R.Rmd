#  Введение в анализ данных в R {#R_analysis} 

Эта книжка написана с помощью языка программирования и обработки данных R и пакета Bookdown в среде работы с данными RStudio.

Чтобы начать в ней работать, нужно скачать и установить сам язык R https://cran.r-project.org/ и скачать и установить RStudio, среду для работы https://posit.co/downloads/.

## Данные и переменные

**Данные** – это информация, представленная в форме, пригодной для хранения и обработки человеком или информационными системами (ISO/IEC/IEEE 24765-2010).
Если данные представлены в форме для обработки информационными системами, они формализованы.

**Переменная** – это оболочка, которую мы задаем, чтобы хранить в ней данные и выполнять операции с ними.
У переменной есть *название* и те *данные*, которая она хранит.

<p align="center"> 
```{r eval=TRUE, echo = FALSE, message = FALSE, fig.align = 'center', out.width="80%"}
knitr::include_graphics("docs/images/variable.png")
```
</p>

### Основные типы данных

* **Числовой** (целые числа – **integer** или **numeric**, вещественные числа – **real**, числа с плавающей точкой (дробные) – **float**)
* **Текстовый** (**character**, если один символ, или **string** – много символов)
* **Логический** (**logical** или **boolean** – принимает только значения True / False)
* **NA** – пропущенные значения (not available)
* **NaN** – not a number, результат выполнения невозможной числовой операции (например, деление на 0)

### Основные структуры данных {#data_structures}

* **Вектор (vector)** – одномерный массив одного типа данных
* **Массив (array)** – многомерный массив одного типа данных, состоящий из векторов одной длины 
* **Матрица (matrix)** – двумерный массив только числовых данных
* **Список (list)** – по сути, многомерный массив, но может состоять из векторов разной длины и иметь данные разных типв
* **Данные, датафрейм (dataframe)** – по сути, cписок, но все вектора одной длины

<p align="center"> 
```{r eval=TRUE, echo = FALSE, message = FALSE, fig.align = 'center', out.width="80%"}
knitr::include_graphics("docs/images/arrays.png")
```
https://practicum.yandex.ru/blog/10-osnovnyh-struktur-dannyh/
</p>


## Операции с переменными и функции {#operarions}

В зависимости от того, с переменными какого типа мы работаем, мы можем выполнять с ними разные операции.

**Операция** – это выполнение каких-либо действий над данными. То, что выполняет это действие, называется **оператором** или **функцией**. Разница между ними в том, что оператор выполняет атомарные (единичные и простые действия), например, оператором может быть знак сложения, деления, больше или меньше и тд. Функция делает более сложные действия: например, создать вектор с помощью функции `c()`, прочитать данные с помощью функции `read_csv()`, отфильтровать данные с помощью функции `select()`. Обратите внимание, что при вызове функции после ее названия всегда ставятся круглые скобки.

| **Тип данных** |                      **Возможные атомарные операции**                     |
|:--------------:|:---------------------------------------------------------------:|
|    Числовой    |                  = (присвоение), +, -, /, *, %                  |
|    Текстовый   | = (присвоение),+ (конкатенация), поиск по определенному символу |
|   Логический   |          = (присвоение),>, <, == (равно), != (не равно)         |


```{r eval=TRUE, echo = TRUE, message = FALSE}
# создание векторов
c(1, 2, 3, 4, 5) # c() -- это  функция
c(1, 2, 3, 4, 5, 7, 21, 143)

1:5 #функция перечисления всех значений от 1 до 5
1:10 #функция перечисления всех значений от 1 до 10

seq(1, 10, 2) # функция перечисления всех значений от 1 до 10 с шагом 2

#пример приведения типов -- TRUE и FALSE превратились в 1 и 0
c(1, 2, 3, 4, 5, TRUE, FALSE)
c(1, 2, 3, 4, 5, "1", "0")

# логические выражения

a <- 5
b <- 10

a > b
a >= b
a == b
a != b
a <= b
a < b

#функция, которая выполняет действия в зависимости от условия ...если ... то:
# ifelse() содержит 3 аргумента: ( условие; что делать, если условие верно;
# что делать, если условие ложно)

ifelse(a < b, a+b, "а не меньше b")
```
## Начало работы в среде

В этом учебнике я буду приводить задания для тренировки в любой среде работы с данными и код работы с данными в R.

Для большинства интересных операций в R нам понадобятся дополнительные пакеты -- набор функций, которые уже кто-то написал за нас (то же самое, как, например, `import numpy as np` в питоне). Нам в основном понадобится пакет `tidyverse`, дословно -- "вселенная чистых данных`. Сразу скажу, что все помеченной символом # -- это комментарии, наши подсказки, которые не будут исполняться. Их важно всего оставлять для себя, чтобы не забыть, что вообще здесь происходит.

Чтобы пакет заработал, его нужно 1. установить и 2. подключить

```{r eval=FALSE, echo = TRUE, message = FALSE}
# устанавливаем пакет
install.packages("tidyverse")
```

```{r eval=TRUE, echo = TRUE, message = FALSE}
# подключаем пакет
library(tidyverse)
```

Установить пакет достаточно всего один раз после установки R, подключать через `library` нужно всегда, когда открываем RStudio. Ошибка вида "could not find function" в 99% случаев говорит о том, что пакет, из которого она используется, не подключен.

## Начало работы с данными

Мы будем работать с данными World Happiness Report за 2016 год https://www.kaggle.com/datasets/unsdsn/world-happiness. Это Всемирный доклад о счастье https://en.wikipedia.org/wiki/World_Happiness_Report , которой показывает, как жители разных стран оценивают свой уровень счастья. В данных за 2016 год, с которыми мы будем работать, участвую 157 стран. *Кстати, вы можете скачать данные за разные года и посмотреть, как менялось количество стран-участниц? Чуть позже мы научимся делать это с помощью кода*. Здесь есть следующие переменные:

* Happiness Rank - позиция в рейтинге
* Happiness Score - абсолютное значение, набранное по уровню счастья
* SE - стандартная ошибка 
* Economy - ВВП на душу населения
* Family - Социальная поддержка, ощущение семье
* Health - Продолжительность жизни
* Freedom - Свободы
* Trust (Goverment Corruption) - воспринимаемый уровень коррупции
* Generosity - сколько жертвуют на благотворительность
* Dystopia - страна-антиутопия, где самые низкие показатели по всем парметрам из существующих


Economy, Family, Health, Freedom, Trust, Generosity -- 6 показателей, по которым считается уровень счастья.

Чтобы совершать операции с данными, их сначала нужно *прочитать*, загрузить в среду работы с данными. В современных традициях R это проще всего сделать с помощью функции `read_csv()` из пакета `tidyverse`. Не забывайте, что любой вызов функции сопровождается круглыми скобками, в которые передаются аргументы. В функции `read_csv()`в скобках нужно передать путь к файлу, который мы хотим прочитать.Его можно скопировать через свойства файла. Но чтобы не заморачиваться с путем, проще всего положить файл с данными в ту же папку, где и лежит наш сам файл с кодом (для этого его нужно сохранить). А самое элегентное и используемое решение -- создать проект File - New Project, и хранить все файл в папке проекта, это уберагает от большого числа ошибок. Про импорт файлов очень подробно расписано у Ивана Позднякова https://pozdniakov.github.io/tidy_stats/030-import_data.html


```{r eval=TRUE, echo = TRUE, message = FALSE}

whr <- read_csv("2016.csv") # читаем данные 

View(whr) # просматриваем, что получилось передать в объект с названием whr 
```


Теперь я хочу поизучать эти данные. Помните, с чего мы начинаем изучение данных? С [описательных статистик](descriptives)

Я могу отобрать все переменные по одной и посчитать для них среднее и стандартное отклонение -- это то, что в Jamovi находится во вкладке Descriptives. Так как колонка существует не в вакууме, а внутри датасета, то нам необходимо как-то указать, что нас интересует конкретная колонка внутри конкретного датасета. Пока что проще всего это сделать -- с помощью значка `$`:

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr$Family # отбираем всю колонку 
```

Или можем вспомнить, что датафрейм имеет два измерения, как и [двумерный массив](data_structures), и можем обратиться по индексу (в квадртных скобках): номер строки (первое число) и номер колонки (второе число). Если нас интересует не конкретная строка, а все строки, то на месте этого индекс ничего не ставится, как бы пропускаем его.

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr[,8] # отбираем всю колонку другим способом
```
Обратите внимание на выдачу: как вы думаете, какым структурам данных принадлежат результаты первого и второго способа?


Посчитаем среднее и стандартное отклонение для этой колонки

```{r eval=TRUE, echo = TRUE, message = FALSE}
mean(whr$Family) # среднее
sd(whr$Family) # стандартное отклонение
```

## Задания после семинара 2 {#tasks_sem2}

1. Прочитайте в среде, в которой вы работаете, данные WHR за 2016 год. 
2. Посчитайте среднее, стандартное отклонение, медиану и размах (разброс от максимального до минимального значения) по всем 6 показателям, составляющим уровень счастья. Что можно сказать про них? Где самый большой размах? Где среднее и медиана оказались близко друг к другу, а где не очень? *(для подсчета медианы и размаха в R нужно будет немножко поучиться гуглить или использовать другие материалы)*

## Предобработка данных {#preprocessing}

После того, как мы считали данные данные в переменную (мы использовали функцию `read_csv()` для этого), часто нужно эти данные сначала **предобработать**. Во-первых, данные сами по себе могут быть не очень хорошего качества, и их нужно почистить. Во-вторых, мы никогда не работаем со всей табличкй сразу -- мы отбираем данные, например, определенную колонку, и часто нам нужны не все данные, а только соответствующие определенным условиям (например, нам нужно отобрать время реакции в группе, где испытуемые употребляли кофеин, а не плацебо). 

В предобработку данных чаще всего входит:

* Отбор определенных колонок
* Фильтрация -- отбор определенных строк, удовлетворяющих определенным условиям
* Создание новых колонок и заполнение их в соответствии с определенными услвиями
* Работа с пропущенными значениями -- удаление или замена на какое-либо (например, среднее) значение

Пойдем по порядку.

### Отбор колонок {#columns}

Любое почти всегда можно сделать разными способами. Чаще всего не существует правильного, если работает -- значит, правильно. Но некоторые решения бывает более оптимальными в разных контекстах. Рассмотрим разные способы отбора колонок. Обратите внимание, чем они различаются?

*Сразу комментарий -- когда мы делаем операцию присвоения <-, у нас ничего не выводится в консоль. Чтобы посмотреть, что мы присвоили переменной, можно вывести ее по названию или, если речь про данные -- посмотреть с помощью функции View(). Если вы только пробуете написать операцию -- не спешите присваивать ее в переменную! Так мы сразу будем видеть результат в консоли, и если он ошибочный, это будет понятно.*

**Отбор в базовом R по названию колонки**

```{r eval=TRUE, echo = TRUE, message = FALSE}
var1 <- whr$`Happiness Score`
var1
str(var1)
```

**Отбор в базовом R по индексу**

Индекс -- это номер элемента в структуре данных. Мы говорили про них, когда обсуждали многомерные массивы: в одномерной структуре, например, векторе, индекс будет состоять из одного числа, в двумернй (например, матрице или датафрейме) -- индекс состоит из двух чисел, разделенных запятой, в трехмерной -- из трех, и так далее. Индекс в R всегда пишется в квадратных скобках, например, чтобы узнать, что находится во второй строчке третьего столбца, индекс элемента будет `[2,3]`.
**Сначала идет номер строки, затем -- номер столбца.** Если мы хотим вывести все строки или все столбцы -- на месте этого индекса ничего не ставится. Например, если я хочу вывести все строки из третьей колонки, я напишу `[,3]`

```{r eval=TRUE, echo = TRUE, message = FALSE}
var2 <- whr[,4]
var2
str(var2)
```
**Отбор с помощью пакета tidyverse по названию**

Сначала пара важных моментов отнсосительно работы с пакетом и кульурой написания кода `tidyverse`. Последовательность операций в рамках одной задачи пишется построчно с переносом на следующую строку в виде [пайпа](https://magrittr.tidyverse.org/reference/pipe.html) ` %>% ` -- символа, который позволяет испльзовать в качестве аргумента функции следующей строки то, что получилось в результате выполнения предыдущей. На первой строке в пайп передаются сами данные, то есть название переменной, в которую мы их записали. Далее на каждой следующей строке в качестве первого аргумента функции в скобках будет применяться результат выполнения предыдущей. Подробнее про tidyverse https://pozdniakov.github.io/tidy_stats/110-tidyverse_basic.html и про пайпы https://pozdniakov.github.io/tidy_stats/110-tidyverse_basic.html

Внутри `tidyverse` используется такая структура данных, как `tibble`(https://tibble.tidyverse.org/). Тиббл -- это модицифированный датафрейм, о чем мы уже говорили, когда обсуждали [структуры данных](#data_structures)

Вывод в датафрейм (тиббл):
```{r eval=TRUE, echo = TRUE, message = FALSE}
var3 <- whr %>%
  select(`Happiness Score`)
var3

#смотрим структуру данных
str(var3)
```

С помощью функции `select()` мы можем вытаскивать даже не одну колонку, а несколько:

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  select(Country,`Happiness Score`)
```

**Отбор с помощью пакета tidyverse по названию**

Обратите внимание -- предыдущий вывод так же является тибблом, а не вектором. Чтобы вывести в вектор, надо выполнить еще один шаг с помощью функции `pull()`, которая как бы "вытягивает" значения из тиббла:
```{r eval=TRUE, echo = TRUE, message = FALSE}
var4 <- whr %>%
  select(`Happiness Score`) %>%
  pull()
var4

#смотрим структуру данных
str(var4)
```

В этом случае мы можем даже в этом же пайпе посчитать медиану или среднее:
```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  select(`Happiness Score`) %>% #результат -- тиббл
  pull() %>% #результат -- вектор
  median()
```

А так будет ошибка

```{r eval=FALSE, echo = TRUE, message = FALSE}
whr %>%
  select(`Happiness Score`) %>% #результат -- тиббл
  median()
```
### Фильтрация (отбор строк) {#filter}

Очень часто встает задача фильтрации строк: когда нужны не все данные, а удовлетворяющие какому-либо условию


```{r eval=TRUE, echo = TRUE, message = FALSE}
whr[1:10,]
```

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>% 
  slice(1:10)
```

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  filter(Region == "Central and Eastern Europe") 
```

А теперь отфильтруем эти значения и возьмем только те значения `Happiness Score`, которые соответствуют Центральной и восточной Европе

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  filter(Region == "Central and Eastern Europe")  %>%
  select(`Happiness Score`) 
```

.. и "вытащим" эти значения в числовой вектор, чтобы с ними было проще всего работать

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  filter(Region == "Central and Eastern Europe") %>%
  select(`Happiness Score`) %>%
  pull() 
```

И посчитаем среднее

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  filter(Region == "Central and Eastern Europe") %>%
  select(`Happiness Score`) %>%
  pull() %>% 
  mean()
```

Теперь можем сравнить средний `Happiness Score` по всем странам (считали его ранее) и только по Центральной и восточной Европе. Что можно про них сказать?

Или посмотрим, какие страны находятся в топе-10 по `Happiness Rank`

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr %>%
  filter(`Happiness Rank` <= 10) 
```



### Создание колонок {#mutate}

Часто возникает задача перекодировать переменную -- например, разбить непрерывные значения на группы, чтобы посмотреть различия между ними.

Например, продолжая предыдущий пример с фильтрацией первых 10 в рейтинге стран: для сравнения показателей, вклдывающихся в уровень счастья, нас может интересовать, отличаются ли "топовые" страны от всех остальных. Для этого нам проще создать отдельную колонку, которая служит индикатором, является ли страна "топовой". Разберем, что это значит: нам нужно 1) создать новую колонку и 2) записать в нее значения, удовлятворяющие определенному условию. (1) достигается с помощью функции `mutate()` (как бы "измени" датафрейм, "примутируй" к нему колонку), а (2) достигается очень похожим на фильтрацию способом -- с помощью функции `ifelse` ([пример выше](#operarions))

На паре топовые и не топовые страны превратились в `hehe` и `not hehe`, так и оставим.

```{r eval=TRUE, echo = TRUE, message = FALSE}
whr_top <- whr %>% 
  mutate("Rank Category" = ifelse(`Happiness Rank` <=10, "hehe", "not hehe"))

whr_top
```

Видим, что на последнем месте появилась новая колонка `Rank Category`.

## Задания после семинара 3 {#tasks_sem3}

1. Выполните все примеры, которые есть в этом разделе, убедитесь, что все работает верно.
2. Посмотрите, какие страны находятся на местах с 1 по 10 и с 147 по 157 (в выводе должно быть по две колонки: `Region` и `Happiness Rank`)
3. Сравните средний показатель экономики `Economy (GDP per Capita)` и уровень счастья `Happiness Score` в странах Восточной и центральной (Central and Eastern Europe) и Западной Европы (Western Europe). Что можно сказать про них? Где показатель экономики выше? Где люди чувствуют себя счастливее?
4. Сравните средний показатель экономики`Economy (GDP per Capita)` и уровень счастья `Happiness Score`  в странах Западной Европы (Western Europe) и Южной Азии (Southern Asia). Что можно сказать про них? Где показатель экономики выше? Где люди чувствуют себя счастливее?
5. Посчитайте средний `Happiness Score` по всем странам и выведете страны, которые лежат в границах ± 1 от среднего `Happiness Score` (в выводе должно быть по две колонки: `Region` и `Happiness Score`) *Подсказка: возможно, будет проще посчитать среднее отдельно и сначала сохранить его в переменную*
6. Создайте колонку, в которой будет содержаться информация, в текущей стране `Happiness Score` выше или ниже среднего значения (колонка может быть заполнена, например, значениями upper и lower или любыми другими обозначениями)




