[["R_analysis.html", "13 Введение в анализ данных в R 13.1 Данные и переменные 13.2 Операции с переменными и функции 13.3 Начало работы в среде 13.4 Начало работы с данными 13.5 Задания после семинара 2 13.6 Предобработка данных 13.7 Задания после семинара 3", " 13 Введение в анализ данных в R Эта книжка написана с помощью языка программирования и обработки данных R и пакета Bookdown в среде работы с данными RStudio. Чтобы начать в ней работать, нужно скачать и установить сам язык R https://cran.r-project.org/ и скачать и установить RStudio, среду для работы https://posit.co/downloads/. 13.1 Данные и переменные Данные – это информация, представленная в форме, пригодной для хранения и обработки человеком или информационными системами (ISO/IEC/IEEE 24765-2010). Если данные представлены в форме для обработки информационными системами, они формализованы. Переменная – это оболочка, которую мы задаем, чтобы хранить в ней данные и выполнять операции с ними. У переменной есть название и те данные, которая она хранит. 13.1.1 Основные типы данных Числовой (целые числа – integer или numeric, вещественные числа – real, числа с плавающей точкой (дробные) – float) Текстовый (character, если один символ, или string – много символов) Логический (logical или boolean – принимает только значения True / False) NA – пропущенные значения (not available) NaN – not a number, результат выполнения невозможной числовой операции (например, деление на 0) 13.1.2 Основные структуры данных Вектор (vector) – одномерный массив одного типа данных Массив (array) – многомерный массив одного типа данных, состоящий из векторов одной длины Матрица (matrix) – двумерный массив только числовых данных Список (list) – по сути, многомерный массив, но может состоять из векторов разной длины и иметь данные разных типв Данные, датафрейм (dataframe) – по сути, cписок, но все вектора одной длины https://practicum.yandex.ru/blog/10-osnovnyh-struktur-dannyh/ 13.2 Операции с переменными и функции В зависимости от того, с переменными какого типа мы работаем, мы можем выполнять с ними разные операции. Операция – это выполнение каких-либо действий над данными. То, что выполняет это действие, называется оператором или функцией. Разница между ними в том, что оператор выполняет атомарные (единичные и простые действия), например, оператором может быть знак сложения, деления, больше или меньше и тд. Функция делает более сложные действия: например, создать вектор с помощью функции c(), прочитать данные с помощью функции read_csv(), отфильтровать данные с помощью функции select(). Обратите внимание, что при вызове функции после ее названия всегда ставятся круглые скобки. Тип данных Возможные атомарные операции Числовой = (присвоение), +, -, /, *, % Текстовый = (присвоение),+ (конкатенация), поиск по определенному символу Логический = (присвоение),&gt;, &lt;, == (равно), != (не равно) # создание векторов c(1, 2, 3, 4, 5) # c() -- это функция ## [1] 1 2 3 4 5 c(1, 2, 3, 4, 5, 7, 21, 143) ## [1] 1 2 3 4 5 7 21 143 1:5 #функция перечисления всех значений от 1 до 5 ## [1] 1 2 3 4 5 1:10 #функция перечисления всех значений от 1 до 10 ## [1] 1 2 3 4 5 6 7 8 9 10 seq(1, 10, 2) # функция перечисления всех значений от 1 до 10 с шагом 2 ## [1] 1 3 5 7 9 #пример приведения типов -- TRUE и FALSE превратились в 1 и 0 c(1, 2, 3, 4, 5, TRUE, FALSE) ## [1] 1 2 3 4 5 1 0 c(1, 2, 3, 4, 5, &quot;1&quot;, &quot;0&quot;) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;1&quot; &quot;0&quot; # логические выражения a &lt;- 5 b &lt;- 10 a &gt; b ## [1] FALSE a &gt;= b ## [1] FALSE a == b ## [1] FALSE a != b ## [1] TRUE a &lt;= b ## [1] TRUE a &lt; b ## [1] TRUE #функция, которая выполняет действия в зависимости от условия ...если ... то: # ifelse() содержит 3 аргумента: ( условие; что делать, если условие верно; # что делать, если условие ложно) ifelse(a &lt; b, a+b, &quot;а не меньше b&quot;) ## [1] 15 13.3 Начало работы в среде В этом учебнике я буду приводить задания для тренировки в любой среде работы с данными и код работы с данными в R. Для большинства интересных операций в R нам понадобятся дополнительные пакеты – набор функций, которые уже кто-то написал за нас (то же самое, как, например, import numpy as np в питоне). Нам в основном понадобится пакет tidyverse, дословно – “вселенная чистых данных`. Сразу скажу, что все помеченной символом # – это комментарии, наши подсказки, которые не будут исполняться. Их важно всего оставлять для себя, чтобы не забыть, что вообще здесь происходит. Чтобы пакет заработал, его нужно 1. установить и 2. подключить # устанавливаем пакет install.packages(&quot;tidyverse&quot;) # подключаем пакет library(tidyverse) Установить пакет достаточно всего один раз после установки R, подключать через library нужно всегда, когда открываем RStudio. Ошибка вида “could not find function” в 99% случаев говорит о том, что пакет, из которого она используется, не подключен. 13.4 Начало работы с данными Мы будем работать с данными World Happiness Report за 2016 год https://www.kaggle.com/datasets/unsdsn/world-happiness. Это Всемирный доклад о счастье https://en.wikipedia.org/wiki/World_Happiness_Report , которой показывает, как жители разных стран оценивают свой уровень счастья. В данных за 2016 год, с которыми мы будем работать, участвую 157 стран. Кстати, вы можете скачать данные за разные года и посмотреть, как менялось количество стран-участниц? Чуть позже мы научимся делать это с помощью кода. Здесь есть следующие переменные: Happiness Rank - позиция в рейтинге Happiness Score - абсолютное значение, набранное по уровню счастья SE - стандартная ошибка Economy - ВВП на душу населения Family - Социальная поддержка, ощущение семье Health - Продолжительность жизни Freedom - Свободы Trust (Goverment Corruption) - воспринимаемый уровень коррупции Generosity - сколько жертвуют на благотворительность Dystopia - страна-антиутопия, где самые низкие показатели по всем парметрам из существующих Economy, Family, Health, Freedom, Trust, Generosity – 6 показателей, по которым считается уровень счастья. Чтобы совершать операции с данными, их сначала нужно прочитать, загрузить в среду работы с данными. В современных традициях R это проще всего сделать с помощью функции read_csv() из пакета tidyverse. Не забывайте, что любой вызов функции сопровождается круглыми скобками, в которые передаются аргументы. В функции read_csv()в скобках нужно передать путь к файлу, который мы хотим прочитать.Его можно скопировать через свойства файла. Но чтобы не заморачиваться с путем, проще всего положить файл с данными в ту же папку, где и лежит наш сам файл с кодом (для этого его нужно сохранить). А самое элегентное и используемое решение – создать проект File - New Project, и хранить все файл в папке проекта, это уберагает от большого числа ошибок. Про импорт файлов очень подробно расписано у Ивана Позднякова https://pozdniakov.github.io/tidy_stats/030-import_data.html whr &lt;- read_csv(&quot;2016.csv&quot;) # читаем данные View(whr) # просматриваем, что получилось передать в объект с названием whr Теперь я хочу поизучать эти данные. Помните, с чего мы начинаем изучение данных? С описательных статистик Я могу отобрать все переменные по одной и посчитать для них среднее и стандартное отклонение – это то, что в Jamovi находится во вкладке Descriptives. Так как колонка существует не в вакууме, а внутри датасета, то нам необходимо как-то указать, что нас интересует конкретная колонка внутри конкретного датасета. Пока что проще всего это сделать – с помощью значка $: whr$Family # отбираем всю колонку ## [1] 1.16374 1.14524 1.18326 1.12690 1.13464 1.09610 1.02912 1.17278 1.10476 ## [10] 1.08764 0.99537 1.08383 1.04782 1.02152 1.08113 1.09774 1.03938 1.05249 ## [19] 1.16157 1.03999 0.71460 0.86758 1.08672 0.90587 0.98912 1.06612 1.00793 ## [28] 0.87114 1.03143 1.09879 1.02169 1.00508 1.04477 0.84829 0.92624 0.87964 ## [37] 1.12945 0.83309 0.87119 0.77866 0.87758 0.94397 0.98569 1.03302 1.08268 ## [46] 0.80975 0.88025 0.89521 1.16810 1.04167 0.85974 0.68655 1.06054 0.95544 ## [55] 0.83132 1.05261 1.04685 0.72194 0.83779 1.06411 1.04993 0.81826 1.05613 ## [64] 0.81255 1.03817 0.75695 0.95076 0.95025 0.70697 1.11111 0.72803 1.05163 ## [73] 0.96372 0.60809 0.87021 0.33613 0.66062 0.87717 0.87625 0.86216 0.76042 ## [82] 0.87877 0.79381 0.90836 0.95434 0.81329 0.64367 0.74173 0.99496 0.38595 ## [91] 0.93164 0.26135 0.64184 0.94367 0.78236 0.79117 0.75862 0.43165 0.75473 ## [100] 0.75602 1.08983 0.54970 0.64498 0.75596 0.38857 0.63760 0.69699 0.71629 ## [109] 0.50163 0.24749 0.62800 0.59205 0.70362 0.62542 0.37932 0.96053 0.84783 ## [118] 0.29247 0.69981 0.49813 0.62477 0.76240 1.01413 0.49353 0.80676 0.19249 ## [127] 0.47799 0.77416 0.92542 0.84142 0.71478 0.14700 0.81928 0.72368 0.86333 ## [136] 0.29561 0.89186 0.60323 0.57576 0.53750 0.66366 0.60530 0.18519 0.63178 ## [145] 0.63054 0.90981 0.47493 0.46115 0.77623 0.50353 0.31090 0.61586 0.10419 ## [154] 0.11037 0.00000 0.14866 0.23442 Или можем вспомнить, что датафрейм имеет два измерения, как и двумерный массив, и можем обратиться по индексу (в квадртных скобках): номер строки (первое число) и номер колонки (второе число). Если нас интересует не конкретная строка, а все строки, то на месте этого индекс ничего не ставится, как бы пропускаем его. whr[,8] # отбираем всю колонку другим способом ## # A tibble: 157 × 1 ## Family ## &lt;dbl&gt; ## 1 1.16 ## 2 1.15 ## 3 1.18 ## 4 1.13 ## 5 1.13 ## 6 1.10 ## 7 1.03 ## 8 1.17 ## 9 1.10 ## 10 1.09 ## # … with 147 more rows Обратите внимание на выдачу: как вы думаете, какым структурам данных принадлежат результаты первого и второго способа? Посчитаем среднее и стандартное отклонение для этой колонки mean(whr$Family) # среднее ## [1] 0.7936211 sd(whr$Family) # стандартное отклонение ## [1] 0.2667057 13.5 Задания после семинара 2 Прочитайте в среде, в которой вы работаете, данные WHR за 2016 год. Посчитайте среднее, стандартное отклонение, медиану и размах (разброс от максимального до минимального значения) по всем 6 показателям, составляющим уровень счастья. Что можно сказать про них? Где самый большой размах? Где среднее и медиана оказались близко друг к другу, а где не очень? (для подсчета медианы и размаха в R нужно будет немножко поучиться гуглить или использовать другие материалы) 13.6 Предобработка данных После того, как мы считали данные данные в переменную (мы использовали функцию read_csv() для этого), часто нужно эти данные сначала предобработать. Во-первых, данные сами по себе могут быть не очень хорошего качества, и их нужно почистить. Во-вторых, мы никогда не работаем со всей табличкй сразу – мы отбираем данные, например, определенную колонку, и часто нам нужны не все данные, а только соответствующие определенным условиям (например, нам нужно отобрать время реакции в группе, где испытуемые употребляли кофеин, а не плацебо). В предобработку данных чаще всего входит: Отбор определенных колонок Фильтрация – отбор определенных строк, удовлетворяющих определенным условиям Создание новых колонок и заполнение их в соответствии с определенными услвиями Работа с пропущенными значениями – удаление или замена на какое-либо (например, среднее) значение Пойдем по порядку. 13.6.1 Отбор колонок Любое почти всегда можно сделать разными способами. Чаще всего не существует правильного, если работает – значит, правильно. Но некоторые решения бывает более оптимальными в разных контекстах. Рассмотрим разные способы отбора колонок. Обратите внимание, чем они различаются? Сразу комментарий – когда мы делаем операцию присвоения &lt;-, у нас ничего не выводится в консоль. Чтобы посмотреть, что мы присвоили переменной, можно вывести ее по названию или, если речь про данные – посмотреть с помощью функции View(). Если вы только пробуете написать операцию – не спешите присваивать ее в переменную! Так мы сразу будем видеть результат в консоли, и если он ошибочный, это будет понятно. Отбор в базовом R по названию колонки var1 &lt;- whr$`Happiness Score` var1 ## [1] 7.526 7.509 7.501 7.498 7.413 7.404 7.339 7.334 7.313 7.291 7.267 7.119 ## [13] 7.104 7.087 7.039 6.994 6.952 6.929 6.907 6.871 6.778 6.739 6.725 6.705 ## [25] 6.701 6.650 6.596 6.573 6.545 6.488 6.481 6.478 6.474 6.379 6.379 6.375 ## [37] 6.361 6.355 6.324 6.269 6.239 6.218 6.168 6.084 6.078 6.068 6.005 5.992 ## [49] 5.987 5.977 5.976 5.956 5.921 5.919 5.897 5.856 5.835 5.835 5.822 5.813 ## [61] 5.802 5.771 5.768 5.743 5.658 5.648 5.615 5.560 5.546 5.538 5.528 5.517 ## [73] 5.510 5.488 5.458 5.440 5.401 5.389 5.314 5.303 5.291 5.279 5.245 5.196 ## [85] 5.185 5.177 5.163 5.161 5.155 5.151 5.145 5.132 5.129 5.123 5.121 5.061 ## [97] 5.057 5.045 5.033 4.996 4.907 4.876 4.875 4.871 4.813 4.795 4.793 4.754 ## [109] 4.655 4.643 4.635 4.575 4.574 4.513 4.508 4.459 4.415 4.404 4.395 4.362 ## [121] 4.360 4.356 4.324 4.276 4.272 4.252 4.236 4.219 4.217 4.201 4.193 4.156 ## [133] 4.139 4.121 4.073 4.028 3.974 3.956 3.916 3.907 3.866 3.856 3.832 3.763 ## [145] 3.739 3.739 3.724 3.695 3.666 3.622 3.607 3.515 3.484 3.360 3.303 3.069 ## [157] 2.905 str(var1) ## num [1:157] 7.53 7.51 7.5 7.5 7.41 ... Отбор в базовом R по индексу Индекс – это номер элемента в структуре данных. Мы говорили про них, когда обсуждали многомерные массивы: в одномерной структуре, например, векторе, индекс будет состоять из одного числа, в двумернй (например, матрице или датафрейме) – индекс состоит из двух чисел, разделенных запятой, в трехмерной – из трех, и так далее. Индекс в R всегда пишется в квадратных скобках, например, чтобы узнать, что находится во второй строчке третьего столбца, индекс элемента будет [2,3]. Сначала идет номер строки, затем – номер столбца. Если мы хотим вывести все строки или все столбцы – на месте этого индекса ничего не ставится. Например, если я хочу вывести все строки из третьей колонки, я напишу [,3] var2 &lt;- whr[,4] var2 ## # A tibble: 157 × 1 ## `Happiness Score` ## &lt;dbl&gt; ## 1 7.53 ## 2 7.51 ## 3 7.50 ## 4 7.50 ## 5 7.41 ## 6 7.40 ## 7 7.34 ## 8 7.33 ## 9 7.31 ## 10 7.29 ## # … with 147 more rows str(var2) ## tibble [157 × 1] (S3: tbl_df/tbl/data.frame) ## $ Happiness Score: num [1:157] 7.53 7.51 7.5 7.5 7.41 ... Отбор с помощью пакета tidyverse по названию Сначала пара важных моментов отнсосительно работы с пакетом и кульурой написания кода tidyverse. Последовательность операций в рамках одной задачи пишется построчно с переносом на следующую строку в виде пайпа %&gt;% – символа, который позволяет испльзовать в качестве аргумента функции следующей строки то, что получилось в результате выполнения предыдущей. На первой строке в пайп передаются сами данные, то есть название переменной, в которую мы их записали. Далее на каждой следующей строке в качестве первого аргумента функции в скобках будет применяться результат выполнения предыдущей. Подробнее про tidyverse https://pozdniakov.github.io/tidy_stats/110-tidyverse_basic.html и про пайпы https://pozdniakov.github.io/tidy_stats/110-tidyverse_basic.html Внутри tidyverse используется такая структура данных, как tibble(https://tibble.tidyverse.org/). Тиббл – это модицифированный датафрейм, о чем мы уже говорили, когда обсуждали структуры данных Вывод в датафрейм (тиббл): var3 &lt;- whr %&gt;% select(`Happiness Score`) var3 ## # A tibble: 157 × 1 ## `Happiness Score` ## &lt;dbl&gt; ## 1 7.53 ## 2 7.51 ## 3 7.50 ## 4 7.50 ## 5 7.41 ## 6 7.40 ## 7 7.34 ## 8 7.33 ## 9 7.31 ## 10 7.29 ## # … with 147 more rows #смотрим структуру данных str(var3) ## tibble [157 × 1] (S3: tbl_df/tbl/data.frame) ## $ Happiness Score: num [1:157] 7.53 7.51 7.5 7.5 7.41 ... С помощью функции select() мы можем вытаскивать даже не одну колонку, а несколько: whr %&gt;% select(Country,`Happiness Score`) ## # A tibble: 157 × 2 ## Country `Happiness Score` ## &lt;chr&gt; &lt;dbl&gt; ## 1 Denmark 7.53 ## 2 Switzerland 7.51 ## 3 Iceland 7.50 ## 4 Norway 7.50 ## 5 Finland 7.41 ## 6 Canada 7.40 ## 7 Netherlands 7.34 ## 8 New Zealand 7.33 ## 9 Australia 7.31 ## 10 Sweden 7.29 ## # … with 147 more rows Отбор с помощью пакета tidyverse по названию Обратите внимание – предыдущий вывод так же является тибблом, а не вектором. Чтобы вывести в вектор, надо выполнить еще один шаг с помощью функции pull(), которая как бы “вытягивает” значения из тиббла: var4 &lt;- whr %&gt;% select(`Happiness Score`) %&gt;% pull() var4 ## [1] 7.526 7.509 7.501 7.498 7.413 7.404 7.339 7.334 7.313 7.291 7.267 7.119 ## [13] 7.104 7.087 7.039 6.994 6.952 6.929 6.907 6.871 6.778 6.739 6.725 6.705 ## [25] 6.701 6.650 6.596 6.573 6.545 6.488 6.481 6.478 6.474 6.379 6.379 6.375 ## [37] 6.361 6.355 6.324 6.269 6.239 6.218 6.168 6.084 6.078 6.068 6.005 5.992 ## [49] 5.987 5.977 5.976 5.956 5.921 5.919 5.897 5.856 5.835 5.835 5.822 5.813 ## [61] 5.802 5.771 5.768 5.743 5.658 5.648 5.615 5.560 5.546 5.538 5.528 5.517 ## [73] 5.510 5.488 5.458 5.440 5.401 5.389 5.314 5.303 5.291 5.279 5.245 5.196 ## [85] 5.185 5.177 5.163 5.161 5.155 5.151 5.145 5.132 5.129 5.123 5.121 5.061 ## [97] 5.057 5.045 5.033 4.996 4.907 4.876 4.875 4.871 4.813 4.795 4.793 4.754 ## [109] 4.655 4.643 4.635 4.575 4.574 4.513 4.508 4.459 4.415 4.404 4.395 4.362 ## [121] 4.360 4.356 4.324 4.276 4.272 4.252 4.236 4.219 4.217 4.201 4.193 4.156 ## [133] 4.139 4.121 4.073 4.028 3.974 3.956 3.916 3.907 3.866 3.856 3.832 3.763 ## [145] 3.739 3.739 3.724 3.695 3.666 3.622 3.607 3.515 3.484 3.360 3.303 3.069 ## [157] 2.905 #смотрим структуру данных str(var4) ## num [1:157] 7.53 7.51 7.5 7.5 7.41 ... В этом случае мы можем даже в этом же пайпе посчитать медиану или среднее: whr %&gt;% select(`Happiness Score`) %&gt;% #результат -- тиббл pull() %&gt;% #результат -- вектор median() ## [1] 5.314 А так будет ошибка whr %&gt;% select(`Happiness Score`) %&gt;% #результат -- тиббл median() 13.6.2 Фильтрация (отбор строк) Очень часто встает задача фильтрации строк: когда нужны не все данные, а удовлетворяющие какому-либо условию whr[1:10,] ## # A tibble: 10 × 13 ## Country Region Happi…¹ Happi…² Lower…³ Upper…⁴ Econo…⁵ Family Healt…⁶ Freedom ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark Weste… 1 7.53 7.46 7.59 1.44 1.16 0.795 0.579 ## 2 Switze… Weste… 2 7.51 7.43 7.59 1.53 1.15 0.863 0.586 ## 3 Iceland Weste… 3 7.50 7.33 7.67 1.43 1.18 0.867 0.566 ## 4 Norway Weste… 4 7.50 7.42 7.58 1.58 1.13 0.796 0.596 ## 5 Finland Weste… 5 7.41 7.35 7.48 1.41 1.13 0.811 0.571 ## 6 Canada North… 6 7.40 7.34 7.47 1.44 1.10 0.828 0.574 ## 7 Nether… Weste… 7 7.34 7.28 7.39 1.46 1.03 0.812 0.552 ## 8 New Ze… Austr… 8 7.33 7.26 7.40 1.36 1.17 0.831 0.581 ## 9 Austra… Austr… 9 7.31 7.24 7.38 1.44 1.10 0.851 0.568 ## 10 Sweden Weste… 10 7.29 7.23 7.36 1.45 1.09 0.831 0.582 ## # … with 3 more variables: `Trust (Government Corruption)` &lt;dbl&gt;, ## # Generosity &lt;dbl&gt;, `Dystopia Residual` &lt;dbl&gt;, and abbreviated variable names ## # ¹​`Happiness Rank`, ²​`Happiness Score`, ³​`Lower Confidence Interval`, ## # ⁴​`Upper Confidence Interval`, ⁵​`Economy (GDP per Capita)`, ## # ⁶​`Health (Life Expectancy)` whr %&gt;% slice(1:10) ## # A tibble: 10 × 13 ## Country Region Happi…¹ Happi…² Lower…³ Upper…⁴ Econo…⁵ Family Healt…⁶ Freedom ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark Weste… 1 7.53 7.46 7.59 1.44 1.16 0.795 0.579 ## 2 Switze… Weste… 2 7.51 7.43 7.59 1.53 1.15 0.863 0.586 ## 3 Iceland Weste… 3 7.50 7.33 7.67 1.43 1.18 0.867 0.566 ## 4 Norway Weste… 4 7.50 7.42 7.58 1.58 1.13 0.796 0.596 ## 5 Finland Weste… 5 7.41 7.35 7.48 1.41 1.13 0.811 0.571 ## 6 Canada North… 6 7.40 7.34 7.47 1.44 1.10 0.828 0.574 ## 7 Nether… Weste… 7 7.34 7.28 7.39 1.46 1.03 0.812 0.552 ## 8 New Ze… Austr… 8 7.33 7.26 7.40 1.36 1.17 0.831 0.581 ## 9 Austra… Austr… 9 7.31 7.24 7.38 1.44 1.10 0.851 0.568 ## 10 Sweden Weste… 10 7.29 7.23 7.36 1.45 1.09 0.831 0.582 ## # … with 3 more variables: `Trust (Government Corruption)` &lt;dbl&gt;, ## # Generosity &lt;dbl&gt;, `Dystopia Residual` &lt;dbl&gt;, and abbreviated variable names ## # ¹​`Happiness Rank`, ²​`Happiness Score`, ³​`Lower Confidence Interval`, ## # ⁴​`Upper Confidence Interval`, ⁵​`Economy (GDP per Capita)`, ## # ⁶​`Health (Life Expectancy)` whr %&gt;% filter(Region == &quot;Central and Eastern Europe&quot;) ## # A tibble: 29 × 13 ## Country Region Happi…¹ Happi…² Lower…³ Upper…⁴ Econo…⁵ Family Healt…⁶ Freedom ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Czech … Centr… 27 6.60 6.52 6.68 1.31 1.01 0.764 0.414 ## 2 Slovak… Centr… 45 6.08 6.00 6.16 1.28 1.08 0.704 0.234 ## 3 Uzbeki… Centr… 49 5.99 5.90 6.08 0.736 1.17 0.502 0.608 ## 4 Kazakh… Centr… 54 5.92 5.84 6.00 1.23 0.955 0.574 0.405 ## 5 Moldova Centr… 55 5.90 5.82 5.97 0.692 0.831 0.523 0.252 ## 6 Russia Centr… 56 5.86 5.79 5.92 1.23 1.05 0.590 0.327 ## 7 Poland Centr… 57 5.84 5.75 5.92 1.25 1.05 0.691 0.452 ## 8 Lithua… Centr… 60 5.81 5.73 5.89 1.27 1.06 0.647 0.189 ## 9 Belarus Centr… 61 5.80 5.72 5.88 1.13 1.05 0.631 0.291 ## 10 Sloven… Centr… 63 5.77 5.68 5.85 1.30 1.06 0.792 0.532 ## # … with 19 more rows, 3 more variables: `Trust (Government Corruption)` &lt;dbl&gt;, ## # Generosity &lt;dbl&gt;, `Dystopia Residual` &lt;dbl&gt;, and abbreviated variable names ## # ¹​`Happiness Rank`, ²​`Happiness Score`, ³​`Lower Confidence Interval`, ## # ⁴​`Upper Confidence Interval`, ⁵​`Economy (GDP per Capita)`, ## # ⁶​`Health (Life Expectancy)` А теперь отфильтруем эти значения и возьмем только те значения Happiness Score, которые соответствуют Центральной и восточной Европе whr %&gt;% filter(Region == &quot;Central and Eastern Europe&quot;) %&gt;% select(`Happiness Score`) ## # A tibble: 29 × 1 ## `Happiness Score` ## &lt;dbl&gt; ## 1 6.60 ## 2 6.08 ## 3 5.99 ## 4 5.92 ## 5 5.90 ## 6 5.86 ## 7 5.84 ## 8 5.81 ## 9 5.80 ## 10 5.77 ## # … with 19 more rows .. и “вытащим” эти значения в числовой вектор, чтобы с ними было проще всего работать whr %&gt;% filter(Region == &quot;Central and Eastern Europe&quot;) %&gt;% select(`Happiness Score`) %&gt;% pull() ## [1] 6.596 6.078 5.987 5.919 5.897 5.856 5.835 5.813 5.802 5.768 5.658 5.560 ## [13] 5.528 5.517 5.488 5.401 5.291 5.185 5.177 5.163 5.161 5.145 5.121 4.996 ## [25] 4.655 4.360 4.324 4.252 4.217 И посчитаем среднее whr %&gt;% filter(Region == &quot;Central and Eastern Europe&quot;) %&gt;% select(`Happiness Score`) %&gt;% pull() %&gt;% mean() ## [1] 5.37069 Теперь можем сравнить средний Happiness Score по всем странам (считали его ранее) и только по Центральной и восточной Европе. Что можно про них сказать? Или посмотрим, какие страны находятся в топе-10 по Happiness Rank whr %&gt;% filter(`Happiness Rank` &lt;= 10) ## # A tibble: 10 × 13 ## Country Region Happi…¹ Happi…² Lower…³ Upper…⁴ Econo…⁵ Family Healt…⁶ Freedom ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark Weste… 1 7.53 7.46 7.59 1.44 1.16 0.795 0.579 ## 2 Switze… Weste… 2 7.51 7.43 7.59 1.53 1.15 0.863 0.586 ## 3 Iceland Weste… 3 7.50 7.33 7.67 1.43 1.18 0.867 0.566 ## 4 Norway Weste… 4 7.50 7.42 7.58 1.58 1.13 0.796 0.596 ## 5 Finland Weste… 5 7.41 7.35 7.48 1.41 1.13 0.811 0.571 ## 6 Canada North… 6 7.40 7.34 7.47 1.44 1.10 0.828 0.574 ## 7 Nether… Weste… 7 7.34 7.28 7.39 1.46 1.03 0.812 0.552 ## 8 New Ze… Austr… 8 7.33 7.26 7.40 1.36 1.17 0.831 0.581 ## 9 Austra… Austr… 9 7.31 7.24 7.38 1.44 1.10 0.851 0.568 ## 10 Sweden Weste… 10 7.29 7.23 7.36 1.45 1.09 0.831 0.582 ## # … with 3 more variables: `Trust (Government Corruption)` &lt;dbl&gt;, ## # Generosity &lt;dbl&gt;, `Dystopia Residual` &lt;dbl&gt;, and abbreviated variable names ## # ¹​`Happiness Rank`, ²​`Happiness Score`, ³​`Lower Confidence Interval`, ## # ⁴​`Upper Confidence Interval`, ⁵​`Economy (GDP per Capita)`, ## # ⁶​`Health (Life Expectancy)` 13.6.3 Создание колонок Часто возникает задача перекодировать переменную – например, разбить непрерывные значения на группы, чтобы посмотреть различия между ними. Например, продолжая предыдущий пример с фильтрацией первых 10 в рейтинге стран: для сравнения показателей, вклдывающихся в уровень счастья, нас может интересовать, отличаются ли “топовые” страны от всех остальных. Для этого нам проще создать отдельную колонку, которая служит индикатором, является ли страна “топовой”. Разберем, что это значит: нам нужно 1) создать новую колонку и 2) записать в нее значения, удовлятворяющие определенному условию. (1) достигается с помощью функции mutate() (как бы “измени” датафрейм, “примутируй” к нему колонку), а (2) достигается очень похожим на фильтрацию способом – с помощью функции ifelse (пример выше) На паре топовые и не топовые страны превратились в hehe и not hehe, так и оставим. whr_top &lt;- whr %&gt;% mutate(&quot;Rank Category&quot; = ifelse(`Happiness Rank` &lt;=10, &quot;hehe&quot;, &quot;not hehe&quot;)) whr_top ## # A tibble: 157 × 14 ## Country Region Happi…¹ Happi…² Lower…³ Upper…⁴ Econo…⁵ Family Healt…⁶ Freedom ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Denmark Weste… 1 7.53 7.46 7.59 1.44 1.16 0.795 0.579 ## 2 Switze… Weste… 2 7.51 7.43 7.59 1.53 1.15 0.863 0.586 ## 3 Iceland Weste… 3 7.50 7.33 7.67 1.43 1.18 0.867 0.566 ## 4 Norway Weste… 4 7.50 7.42 7.58 1.58 1.13 0.796 0.596 ## 5 Finland Weste… 5 7.41 7.35 7.48 1.41 1.13 0.811 0.571 ## 6 Canada North… 6 7.40 7.34 7.47 1.44 1.10 0.828 0.574 ## 7 Nether… Weste… 7 7.34 7.28 7.39 1.46 1.03 0.812 0.552 ## 8 New Ze… Austr… 8 7.33 7.26 7.40 1.36 1.17 0.831 0.581 ## 9 Austra… Austr… 9 7.31 7.24 7.38 1.44 1.10 0.851 0.568 ## 10 Sweden Weste… 10 7.29 7.23 7.36 1.45 1.09 0.831 0.582 ## # … with 147 more rows, 4 more variables: ## # `Trust (Government Corruption)` &lt;dbl&gt;, Generosity &lt;dbl&gt;, ## # `Dystopia Residual` &lt;dbl&gt;, `Rank Category` &lt;chr&gt;, and abbreviated variable ## # names ¹​`Happiness Rank`, ²​`Happiness Score`, ³​`Lower Confidence Interval`, ## # ⁴​`Upper Confidence Interval`, ⁵​`Economy (GDP per Capita)`, ## # ⁶​`Health (Life Expectancy)` Видим, что на последнем месте появилась новая колонка Rank Category. 13.7 Задания после семинара 3 Выполните все примеры, которые есть в этом разделе, убедитесь, что все работает верно. Посмотрите, какие страны находятся на местах с 1 по 10 и с 147 по 157 (в выводе должно быть по две колонки) Сравните средний показатель экономики Economy (GDP per Capita) и уровень счастья Happiness Score в странах Восточной и центральной (Central and Eastern Europe) и Западной Европы (Western Europe). Что можно сказать про них? Где показатель экономики выше? Где люди чувствуют себя счастливее? Сравните средний показатель экономикиEconomy (GDP per Capita) и уровень счастья Happiness Score в странах Западной Европы (Western Europe) и Южной Азии (Southern Asia). Что можно сказать про них? Где показатель экономики выше? Где люди чувствуют себя счастливее? 5. Посчитайте средний Happiness Score по всем странам и выведете страны, которые лежат в границах ± 1 от среднего Happiness Score (в выводе должно быть по две колонки) 6. Создайте колонку, в которой будет содержаться информации, в текущей стране Happiness Score выше или ниже среднего значения (колонка может быть заполнена, например, значениями upper и lower или любыми другими обозначениями) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
